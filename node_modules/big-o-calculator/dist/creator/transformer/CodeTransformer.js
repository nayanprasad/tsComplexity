"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeTransformer = void 0;
const ArgumentConverters_1 = require("./ArgumentConverters");
class CodeTransformer {
    constructor() {
        this.languageTransformers = new Map();
        this.languagePatterns = new Map();
    }
    createRunnableCode(code, sample) {
        let codeContent = this.applyLanguageSpecialRules(code, sample);
        const syntaxArguments = this.argumentsInLanguageSyntax(code, sample);
        let patterns = [CodeTransformer.REPLACEMENT_PATTERN];
        if (this.languagePatterns.has(code.language)) {
            patterns = this.languagePatterns.get(code.language);
        }
        for (let i = 0; i < patterns.length; i++) {
            codeContent = codeContent.replace(patterns[i], syntaxArguments);
        }
        return codeContent;
    }
    applyLanguageSpecialRules(code, sample) {
        if (this.languageTransformers.has(code.language)) {
            const transformer = this.languageTransformers.get(code.language);
            return transformer(code, sample);
        }
        return code.content;
    }
    argumentsInLanguageSyntax(code, sample) {
        switch (true) {
            case Array.isArray(sample.value):
                return ArgumentConverters_1.convertArray(sample.value, code.language);
            case typeof sample.value === 'string':
                return ArgumentConverters_1.convertString(sample.value);
            default:
                return sample.value.toString();
        }
    }
    addLanguageCodeTransformer(language, transformer) {
        this.languageTransformers.set(language, transformer);
    }
    addLanguageReplacePattern(language, pattern) {
        var _a;
        if (!this.languagePatterns.has(language)) {
            this.languagePatterns.set(language, []);
        }
        (_a = this.languagePatterns.get(language)) === null || _a === void 0 ? void 0 : _a.push(pattern);
    }
    injectFunctionArguments(code, samples) {
        return samples.map(sample => {
            return {
                n: sample.n,
                code: this.createRunnableCode(code, sample),
            };
        });
    }
}
exports.CodeTransformer = CodeTransformer;
CodeTransformer.REPLACEMENT_PATTERN = '{funcArgs}';
//# sourceMappingURL=CodeTransformer.js.map