"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnalysisService = void 0;
const runner_1 = require("./runner");
const structures_1 = require("./structures");
const creator_1 = require("./creator");
const calculator_1 = require("./calculator");
class AnalysisService {
    constructor(codeRunner, config) {
        this.codeRunner = codeRunner;
        this.optimalComplexities = new Map();
        this.calculators = new Map();
        this.repeatedSamples = new Map();
        this.defaultCalculator = new calculator_1.GenericCalculator();
        if (config) {
            if (config.optimalComplexities) {
                this.optimalComplexities = config.optimalComplexities;
            }
            if (config.calculators) {
                this.calculators = config.calculators;
            }
            if (config.repeatedSamples) {
                this.repeatedSamples = config.repeatedSamples;
            }
            if (config.defaultCalculator) {
                this.defaultCalculator = config.defaultCalculator;
            }
        }
        this.testSetCreator = new creator_1.TestSetCreator();
    }
    analyze(code, runnerContext = {}) {
        const testSet = this.testSetCreator.create(code);
        const testResultsObj = { r: [] };
        const calculator = this.calculatorForLanguage(code.language);
        return this.recursiveAnalyze(calculator, testSet, testResultsObj, 0, runnerContext);
    }
    recursiveAnalyze(calculator, testSet, testResultsObj, i = 0, runnerContext = {}) {
        return this.runSample(testSet.code, testSet.samples[i], testResultsObj, runnerContext)
            .then((testResults) => {
            const bigO = calculator.calculate(testResults, testSet.code.expectedSpeed);
            if (bigO !== structures_1.BigO.UNKNOWN) {
                return Promise.resolve({ bigO, testResults });
            }
            if (testResults[testResults.length - 1].result >= calculator_1.TIMEOUT_THRESHOLD_MS) {
                const err = new runner_1.UnexpectedTimeoutError('Calculator could not handle runner timeout.');
                err.testResults = testResults;
                err.code = testSet.code;
                return Promise.reject(err);
            }
            if (i === testSet.samples.length - 1) {
                return Promise.resolve({
                    bigO: this.optimalComplexity(testSet.code.testedFunctionName),
                    testResults
                });
            }
            return this.recursiveAnalyze(calculator, testSet, testResultsObj, ++i, runnerContext);
        });
    }
    runSample(code, sample, testResultsObj, runnerContext = {}) {
        let runs = this.runCountForSample(code.language, sample.n);
        const promises = [];
        while (runs > 0) {
            runs--;
            const durationRunner = this.codeRunner.checkCodeExecDuration(code.language, sample.code, runnerContext)
                .then((duration) => {
                return Promise.resolve({
                    result: duration,
                    n: sample.n
                });
            });
            promises.push(durationRunner);
        }
        return Promise.all(promises)
            .then((runnerResults) => {
            testResultsObj.r = testResultsObj.r.concat(runnerResults);
            return testResultsObj.r;
        }).catch(err => {
            if (err instanceof runner_1.CodeRunnerError) {
                err.failedSample = sample.n;
                err.testResults = testResultsObj.r;
                err.code = code;
            }
            return Promise.reject(err);
        });
    }
    addTestSetCreatorDefaultLanguageSet(language, sampleSizes) {
        this.testSetCreator.addDefaultLanguageSet(language, sampleSizes);
    }
    addTestSetCreatorSpeedLanguageSet(language, speed, sampleSizes) {
        this.testSetCreator.addSpeedLanguageSet(language, speed, sampleSizes);
    }
    useBuiltInGenerator(testedFunctionName, builtInGeneratorName) {
        this.testSetCreator.useBuiltInGenerator(testedFunctionName, builtInGeneratorName);
    }
    addCustomGenerator(testedFunctionName, func) {
        this.testSetCreator.addCustomGenerator(testedFunctionName, func);
    }
    addLanguageCodeTransformer(language, transformer) {
        this.testSetCreator.addLanguageCodeTransformer(language, transformer);
    }
    addLanguageReplacePattern(language, pattern) {
        this.testSetCreator.addLanguageReplacePattern(language, pattern);
    }
    runCountForSample(language, sampleSize) {
        if (this.repeatedSamples.has(language)) {
            const samples = this.repeatedSamples.get(language);
            if (samples.indexOf(sampleSize) !== -1) {
                return 3;
            }
        }
        return 1;
    }
    optimalComplexity(type) {
        if (this.optimalComplexities.has(type)) {
            return this.optimalComplexities.get(type);
        }
        return structures_1.BigO.LINEAR;
    }
    calculatorForLanguage(language) {
        if (this.calculators.has(language)) {
            return this.calculators.get(language);
        }
        return this.defaultCalculator;
    }
}
exports.AnalysisService = AnalysisService;
//# sourceMappingURL=AnalysisService.js.map